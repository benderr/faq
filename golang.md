## 1. Golang

### Оглавление
- [1.1 Базовые вопросы](#11-базовые-вопросы)
  - [Типы данных](#типы-данных)
  - [Что такое type switch](#что-такое-type-switch)
  - [Что такое интерфейсы](#что-такое-интерфейсы)
  - [Зачем нужен defer](#зачем-нужен-defer)
  - [Что такое panic/recover?](#что-такое-panicrecover)
  - [Как передаются данные в Go](#как-передаются-данные-в-go)
- [1.2 Вопросы сложнее](#12-вопросы-сложнее)
  - [Что такое рефлексия и пакет reflect](#что-такое-рефлексия-и-пакет-reflect)
  - [Как в Go организовано наследование/инкапсуляция](#как-в-go-организовано-наследованиеинкапсуляция)
  - [Типы синхронизации](#типы-синхронизации)
  - [Что такое дедлок/фрилок](#что-такое-дедлокфрилок)
  - [Немного про heap/stack](#немного-про-heapstack)
  - [Как сообщить компилятору, что наш тип реализует интерфейс?](#как-сообщить-компилятору-что-наш-тип-реализует-интерфейс)
- [1.3 Вопросы с расширенным ответом](#13-вопросы-с-расширенным-ответом)
  - [Как устроена мапа?](#как-устроена-мапа)
  - [Как устроен слайс?](#как-устроен-слайс)
  - [Как устроены каналы?](#как-устроены-каналы)
  - [Профилирование pprof?](#профилирование-pprof)
  - [Как устроен шедулер?](#как-устроен-шедулер)

---

### 1.1 Базовые вопросы

#### Типы данных
Описание базовых типов данных в Go: int, float, string, bool, а также составные типы (массивы, слайсы, структуры, мапы).

#### Что такое type assertion и type switch

```go
var i interface{} = "Hello"
s := i.(string)  // Преобразование к типу string
fmt.Println(s)   // Вывод: Hello
```

```go
func describe(i interface{}) {
    switch v := i.(type) {
    case int:
        fmt.Println("Это int:", v)
    case string:
        fmt.Println("Это string:", v)
    default:
        fmt.Println("Неизвестный тип")
    }
}
```

#### Что такое интерфейсы
Интерфейс в Go состоит из двух частей:

Указатель на таблицу методов (tab) — содержит информацию о типе и списке методов, которые реализует этот тип.

Указатель на данные (data) — ссылка на конкретное значение, которое хранится в интерфейсе.

На низком уровне это можно представить так:
```go
type iface struct {
    tab  *itab          // Таблица методов
    data unsafe.Pointer // Указатель на данные
}
```
Таблица методов (itab) содержит информацию о типе и методах, которые реализует этот тип. Она включает:

Тип интерфейса — описание интерфейса (например, io.Writer).

Конкретный тип — тип значения, которое хранится в интерфейсе (например, *os.File).

Список методов — указатели на методы, которые реализует конкретный тип для данного интерфейса.

```go
type itab struct {
    inter *interfacetype // Тип интерфейса
    _type *_type         // Конкретный тип
    hash  uint32         // Хэш типа (для быстрого сравнения)
    _     [4]byte
    fun   [1]uintptr     // Список методов (указатели на функции)
}
```

#### Зачем нужен defer
Функции, вызванные с defer, выполняются в порядке LIFO. Это означает, что последний defer будет выполнен первым.

Когда defer используется с замыканием (closure), важно помнить, что замыкание захватывает переменные по ссылке. Это означает, что если переменная изменяется после вызова defer, то в момент выполнения defer будет использовано её последнее значение.

Если нужно, чтобы defer использовал значение переменной на момент вызова, а не на момент выполнения, можно передать переменную в замыкание как аргумент.

defer может изменять возвращаемые значения функции, если используется с именованными возвращаемыми значениями (named return values).

Когда функция завершается, сначала вычисляются возвращаемые значения, затем выполняются отложенные функции (defer), и только после этого функция возвращает управление.


#### Что такое panic/recover?

Пример отлова паники: 
```go
func main() {
    defer func() {
        if r := recover(); r != nil {
            fmt.Println("Recovered from panic:", r)
        }
    }()
    panic("Something went wrong!")
}
```

#### Как передаются данные в Go
Данные в go передаются по значению через копирование, указатели тоже копируются

---

### 1.2 Вопросы сложнее

#### Что такое рефлексия и пакет reflect
Рефлексия в Go: как использовать пакет `reflect` для анализа типов и значений во время выполнения.

#### Как в Go организовано наследование/инкапсуляция
Отсутствие классического наследования в Go: композиция, встраивание и интерфейсы как альтернатива.

#### Типы синхронизации
`sync.Mutex`
`sync.RWMutex`
`sync.Atomic`
`sync.WaitGroup`
`sync.Map`
`channel`

#### Что такое дедлок/фрилок
В отличие от дедлока (взаимной блокировки), где несколько потоков блокируют друг друга, фрилок возникает, когда поток "застревает" в ожидании, но причина блокировки не связана с другими потоками.

#### Немного про heap/stack
Управление памятью в Go: что хранится в heap, а что в stack, и как это влияет на производительность.

#### Как сообщить компилятору, что наш тип реализует интерфейс?
```go
var _ IReader = (*SomeReader)(nil)
```

---

### 1.3 Вопросы с расширенным ответом

#### Как устроена мапа?
[Внутренняя структура мапы в Go: хэш-таблицы, коллизии и производительность.](https://www.youtube.com/watch?v=P_SXTUiA-9Y)

#### Как устроен слайс?
[Слайсы в Go: внутреннее представление, capacity, length и операции (append, copy).](https://www.youtube.com/watch?v=10LW7NROfOQ)

#### Как устроены каналы?
[Каналы в Go: буферизованные и небуферизованные, как они работают на уровне runtime.](https://www.youtube.com/watch?v=ZTJcaP4G4JM&t=3s)

#### Профилирование pprof?
Использование пакета `pprof` для профилирования производительности: CPU, memory, блокировки и горутины.

#### Что такое горутина / GMP / устройство шедулера?
[Секреты внутреннего устройства планировщика Go](https://youtu.be/P2Tzdg8n9hw?si=T21docott-tcg5SI)

---
